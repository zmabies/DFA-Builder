package assignment_02;

/* NAME: ELENE GHAITH ASSAF
 * ID: 201520441
 * COURSE: THEORY OF COMPUTATION -20171
 * ASSIGNMENT 02
 */

import java.util.*;

public class DFA 
{
	//arrays of the user inputed Alphabet, States, and Transition Table
	private char alphabet[];
	private String states[];
	private String trans[][];
	
	//Variables to hold the states
	String currentS;
	//Start state and Final state are defined by user
	String startS;
	String finalS[];
	//reject state for if the character read was not part of the alphabet.
	String rejectS = "rej";
	
	//dictionary so the state machine can run
	Dictionary<String, String> dfa;
	//array of keys that will be generated using the transition table
	String []key;
	
	//variable to hold the word inputed by user
	String word;
	
	//constructor to initialize all attributes and call createDFA(see createDFA)
	DFA(char alphabet[], String states[], String trans[][], String startS, String finalS[])
	{	
		this.alphabet = alphabet;
		this.states = states; 
		this.trans = trans;
		
		this.startS = startS;
		this.finalS = finalS;
		
		this.key = new String[getLength(trans)];
		
		createDFA();
	}//DFA
	
	/* this method will build the DFA using a standard dictionary
	 * the logic behind it is that the keys in the dictionary are generated by concatenating
	 * the state with the letter (i.e. (S1, a) -> S2 becomes S1a -> S2)
	 * when the key is generated it is put into the dictionary
	 * and the value is the corresponding value in the transition table array
	 */
	private void createDFA()
	{
		dfa = new Hashtable<String, String>();	
	    int index = 0;
		for (int i = 0; i < states.length; i++)
		{
			for (int j = 0; j < alphabet.length; j++)
			{
				
				key[index] = (states[i] + alphabet[j]);
				dfa.put(key[index], trans[i][j]);
				
				index++;
			}

		}
		//finally add the reject state into the dictionary
		dfa.put(rejectS, rejectS);
		 
	}//createDFA
	
	//set method for the word
	public void setWord(String w)
	{
		this.word = w;
	}//setWord
	

	/* This method reads the word inputed by the user character by character
	 * and determines which state to go to based on the key derived from the current state + the letter read
	 * (i.e. if the current state is S1 and the letter read is 'a' then the key is S1a)
	 * which then is fed through to the get method in our dfa. the state retrieved is out new current state.
	 * If it encounters a letter that is not an element of our alphabet set, 
	 * then the key is the reject state defined in the attributes, 
	 * once our current state is the reject state, it will stay there until we are finished reading.
	 */
	public boolean isValid()
	{
		char[] temp = alphabet;
		Arrays.sort(temp);
		
		String key;
		currentS = startS;
				
		if (word == "" || word == null)
		{
			return checkFinal(currentS);
		}
		
		for (int i = 0; i < word.length(); i++)
		{
			if((Arrays.binarySearch(temp, word.charAt(i)) >= 0) && (currentS != rejectS))
				key = ((String)currentS + word.charAt(i));
			else
				key = rejectS;
						
			currentS = dfa.get(key);
			
		}
		//pass currentS to the method checkFinal (see checkFinal)
		return checkFinal(currentS);
		
	}//isValid
	
	//simple method to calculate the length of a 2D array
	private int getLength(Object[][] t)
	{
		int length = 0;
		for(int i = 0; i < t.length; i++)
		{
			length += t[i].length;
		}
		return length;
	}//getLength
	
	//simple searching method to determine if the current state is an element of the final state set
	private boolean checkFinal(String current)
	{		
		//System.out.println(current);
		for (int i = 0; i < finalS.length; i++)
		{
			if (current.equals(finalS[i]))
			{
				return true;
			}
		}
		return false;
	}//checkFinal
}
